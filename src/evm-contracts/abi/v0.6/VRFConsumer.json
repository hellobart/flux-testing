{
	"schemaVersion": "2.0.0",
	"contractName": "VRFConsumer",
	"compilerOutput": {
		"abi": [
			{
				"inputs": [
					{
						"internalType": "address",
						"name": "_vrfCoordinator",
						"type": "address"
					},
					{
						"internalType": "address",
						"name": "_link",
						"type": "address"
					}
				],
				"stateMutability": "nonpayable",
				"type": "constructor"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "_requestId",
						"type": "bytes32"
					},
					{
						"internalType": "uint256",
						"name": "_randomness",
						"type": "uint256"
					}
				],
				"name": "fulfillRandomness",
				"outputs": [],
				"stateMutability": "nonpayable",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "",
						"type": "bytes32"
					}
				],
				"name": "nonces",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "randomnessOutput",
				"outputs": [
					{
						"internalType": "uint256",
						"name": "",
						"type": "uint256"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [],
				"name": "requestId",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "",
						"type": "bytes32"
					}
				],
				"stateMutability": "view",
				"type": "function"
			},
			{
				"inputs": [
					{
						"internalType": "bytes32",
						"name": "_keyHash",
						"type": "bytes32"
					},
					{
						"internalType": "uint256",
						"name": "_fee",
						"type": "uint256"
					},
					{
						"internalType": "uint256",
						"name": "_seed",
						"type": "uint256"
					}
				],
				"name": "requestRandomness",
				"outputs": [
					{
						"internalType": "bytes32",
						"name": "requestId",
						"type": "bytes32"
					}
				],
				"stateMutability": "nonpayable",
				"type": "function"
			}
		],
		"devdoc": {
			"methods": {
				"requestRandomness(bytes32,uint256,uint256)": {
					"details": "The source of the seed data must be something which the oraclecannot anticipate. See \"SECURITY CONSIDERATIONS\" above.The fulfillRandomness method receives the output, once it's providedby the Oracle, and verified by the vrfCoordinator.The _keyHash must already be registered with the VRFCoordinator, andthe _fee must exceed the fee specified during registration of the_keyHash.The returned requestId can be used to distinguish responses to *concurrent requests. It is passed as the first argument tofulfillRandomness.",
					"params": {
						"_fee": "The amount of LINK to send with the request",
						"_keyHash": "ID of public key against which randomness is generated",
						"_seed": "Random seed from which output randomness is determined"
					},
					"returns": {
						"requestId": "which will be returned with the response to this request"
					}
				}
			}
		},
		"evm": {
			"bytecode": {
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b506040516106033803806106038339818101604052604081101561003357600080fd5b810190808051906020019092919080519060200190929190505050818181600160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050505061051f806100e46000396000f3fe608060405234801561001057600080fd5b50600436106100565760003560e01c80626d6cae1461005b5780631f1f897f146100795780632f47fd86146100b15780639e317f12146100cf578063dc6cfe1014610111575b600080fd5b610063610167565b6040518082815260200191505060405180910390f35b6100af6004803603604081101561008f57600080fd5b81019080803590602001909291908035906020019092919050505061016d565b005b6100b961017f565b6040518082815260200191505060405180910390f35b6100fb600480360360208110156100e557600080fd5b8101908080359060200190929190505050610185565b6040518082815260200191505060405180910390f35b6101516004803603606081101561012757600080fd5b8101908080359060200190929190803590602001909291908035906020019092919050505061019d565b6040518082815260200191505060405180910390f35b60045481565b80600381905550816004819055505050565b60035481565b60026020528060005260406000206000915090505481565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634000aea0600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1685878660405160200180838152602001828152602001925050506040516020818303038152906040526040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156102af578082015181840152602081019050610294565b50505050905090810190601f1680156102dc5780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b1580156102fd57600080fd5b505af1158015610311573d6000803e3d6000fd5b505050506040513d602081101561032757600080fd5b810190808051906020019092919050505050600061035a858430600260008a8152602001908152602001600020546103ae565b90506103836001600260008881526020019081526020016000205461042890919063ffffffff16565b60026000878152602001908152602001600020819055506103a485826104b0565b9150509392505050565b600084848484604051602001808581526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019450505050506040516020818303038152906040528051906020012060001c9050949350505050565b6000808284019050838110156104a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601b8152602001807f536166654d6174683a206164646974696f6e206f766572666c6f77000000000081525060200191505060405180910390fd5b8091505092915050565b6000828260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012090509291505056fea264697066735822122051fd69bc7c1e79c55d6a3b309e2699daa5ad6d3024390148daf54ddcf77a388a64736f6c63430006020033",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x40 MLOAD PUSH2 0x603 CODESIZE SUB DUP1 PUSH2 0x603 DUP4 CODECOPY DUP2 DUP2 ADD PUSH1 0x40 MSTORE PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x33 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP DUP2 DUP2 DUP2 PUSH1 0x1 PUSH1 0x0 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP DUP1 PUSH1 0x0 DUP1 PUSH2 0x100 EXP DUP2 SLOAD DUP2 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF MUL NOT AND SWAP1 DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND MUL OR SWAP1 SSTORE POP POP POP POP POP PUSH2 0x51F DUP1 PUSH2 0xE4 PUSH1 0x0 CODECOPY PUSH1 0x0 RETURN INVALID PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x56 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH3 0x6D6CAE EQ PUSH2 0x5B JUMPI DUP1 PUSH4 0x1F1F897F EQ PUSH2 0x79 JUMPI DUP1 PUSH4 0x2F47FD86 EQ PUSH2 0xB1 JUMPI DUP1 PUSH4 0x9E317F12 EQ PUSH2 0xCF JUMPI DUP1 PUSH4 0xDC6CFE10 EQ PUSH2 0x111 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x63 PUSH2 0x167 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xAF PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x8F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x16D JUMP JUMPDEST STOP JUMPDEST PUSH2 0xB9 PUSH2 0x17F JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xFB PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xE5 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x185 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x151 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x60 DUP2 LT ISZERO PUSH2 0x127 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x19D JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x4 SLOAD DUP2 JUMP JUMPDEST DUP1 PUSH1 0x3 DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x4 DUP2 SWAP1 SSTORE POP POP POP JUMP JUMPDEST PUSH1 0x3 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x2 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP2 POP SWAP1 POP SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x4000AEA0 PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP6 DUP8 DUP7 PUSH1 0x40 MLOAD PUSH1 0x20 ADD DUP1 DUP4 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE PUSH1 0x40 MLOAD DUP5 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP2 MSTORE PUSH1 0x20 ADD DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x2AF JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0x294 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x2DC JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP5 POP POP POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x2FD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x311 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x327 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP POP PUSH1 0x0 PUSH2 0x35A DUP6 DUP5 ADDRESS PUSH1 0x2 PUSH1 0x0 DUP11 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD PUSH2 0x3AE JUMP JUMPDEST SWAP1 POP PUSH2 0x383 PUSH1 0x1 PUSH1 0x2 PUSH1 0x0 DUP9 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD PUSH2 0x428 SWAP1 SWAP2 SWAP1 PUSH4 0xFFFFFFFF AND JUMP JUMPDEST PUSH1 0x2 PUSH1 0x0 DUP8 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 DUP2 SWAP1 SSTORE POP PUSH2 0x3A4 DUP6 DUP3 PUSH2 0x4B0 JUMP JUMPDEST SWAP2 POP POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP5 DUP5 DUP5 DUP5 PUSH1 0x40 MLOAD PUSH1 0x20 ADD DUP1 DUP6 DUP2 MSTORE PUSH1 0x20 ADD DUP5 DUP2 MSTORE PUSH1 0x20 ADD DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP5 POP POP POP POP POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE DUP1 MLOAD SWAP1 PUSH1 0x20 ADD KECCAK256 PUSH1 0x0 SHR SWAP1 POP SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 DUP3 DUP5 ADD SWAP1 POP DUP4 DUP2 LT ISZERO PUSH2 0x4A6 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE PUSH1 0x1B DUP2 MSTORE PUSH1 0x20 ADD DUP1 PUSH32 0x536166654D6174683A206164646974696F6E206F766572666C6F770000000000 DUP2 MSTORE POP PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP1 SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 PUSH1 0x40 MLOAD PUSH1 0x20 ADD DUP1 DUP4 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE DUP1 MLOAD SWAP1 PUSH1 0x20 ADD KECCAK256 SWAP1 POP SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 MLOAD REVERT PUSH10 0xBC7C1E79C55D6A3B309E 0x26 SWAP10 0xDA 0xA5 0xAD PUSH14 0x3024390148DAF54DDCF77A388A64 PUSH20 0x6F6C634300060200330000000000000000000000 ",
				"sourceMap": "137:443:31:-:0;;;246:167;8:9:-1;5:2;;;30:1;27;20:12;5:2;246:167:31;;;;;;;;;;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;246:167:31;;;;;;;;;;;;;;;;;;;;;;;;;374:15;391:5;6767:15:7;6750:14;;:32;;;;;;;;;;;;;;;;;;6814:5;6788:4;;:32;;;;;;;;;;;;;;;;;;6685:140;;246:167:31;;137:443;;;;;;"
			},
			"deployedBytecode": {
				"linkReferences": {},
				"object": "0x608060405234801561001057600080fd5b50600436106100565760003560e01c80626d6cae1461005b5780631f1f897f146100795780632f47fd86146100b15780639e317f12146100cf578063dc6cfe1014610111575b600080fd5b610063610167565b6040518082815260200191505060405180910390f35b6100af6004803603604081101561008f57600080fd5b81019080803590602001909291908035906020019092919050505061016d565b005b6100b961017f565b6040518082815260200191505060405180910390f35b6100fb600480360360208110156100e557600080fd5b8101908080359060200190929190505050610185565b6040518082815260200191505060405180910390f35b6101516004803603606081101561012757600080fd5b8101908080359060200190929190803590602001909291908035906020019092919050505061019d565b6040518082815260200191505060405180910390f35b60045481565b80600381905550816004819055505050565b60035481565b60026020528060005260406000206000915090505481565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634000aea0600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1685878660405160200180838152602001828152602001925050506040516020818303038152906040526040518463ffffffff1660e01b8152600401808473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200183815260200180602001828103825283818151815260200191508051906020019080838360005b838110156102af578082015181840152602081019050610294565b50505050905090810190601f1680156102dc5780820380516001836020036101000a031916815260200191505b50945050505050602060405180830381600087803b1580156102fd57600080fd5b505af1158015610311573d6000803e3d6000fd5b505050506040513d602081101561032757600080fd5b810190808051906020019092919050505050600061035a858430600260008a8152602001908152602001600020546103ae565b90506103836001600260008881526020019081526020016000205461042890919063ffffffff16565b60026000878152602001908152602001600020819055506103a485826104b0565b9150509392505050565b600084848484604051602001808581526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018281526020019450505050506040516020818303038152906040528051906020012060001c9050949350505050565b6000808284019050838110156104a6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601b8152602001807f536166654d6174683a206164646974696f6e206f766572666c6f77000000000081525060200191505060405180910390fd5b8091505092915050565b6000828260405160200180838152602001828152602001925050506040516020818303038152906040528051906020012090509291505056fea264697066735822122051fd69bc7c1e79c55d6a3b309e2699daa5ad6d3024390148daf54ddcf77a388a64736f6c63430006020033",
				"opcodes": "PUSH1 0x80 PUSH1 0x40 MSTORE CALLVALUE DUP1 ISZERO PUSH2 0x10 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP PUSH1 0x4 CALLDATASIZE LT PUSH2 0x56 JUMPI PUSH1 0x0 CALLDATALOAD PUSH1 0xE0 SHR DUP1 PUSH3 0x6D6CAE EQ PUSH2 0x5B JUMPI DUP1 PUSH4 0x1F1F897F EQ PUSH2 0x79 JUMPI DUP1 PUSH4 0x2F47FD86 EQ PUSH2 0xB1 JUMPI DUP1 PUSH4 0x9E317F12 EQ PUSH2 0xCF JUMPI DUP1 PUSH4 0xDC6CFE10 EQ PUSH2 0x111 JUMPI JUMPDEST PUSH1 0x0 DUP1 REVERT JUMPDEST PUSH2 0x63 PUSH2 0x167 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xAF PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x40 DUP2 LT ISZERO PUSH2 0x8F JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x16D JUMP JUMPDEST STOP JUMPDEST PUSH2 0xB9 PUSH2 0x17F JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0xFB PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x20 DUP2 LT ISZERO PUSH2 0xE5 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x185 JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH2 0x151 PUSH1 0x4 DUP1 CALLDATASIZE SUB PUSH1 0x60 DUP2 LT ISZERO PUSH2 0x127 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 DUP1 CALLDATALOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP PUSH2 0x19D JUMP JUMPDEST PUSH1 0x40 MLOAD DUP1 DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 RETURN JUMPDEST PUSH1 0x4 SLOAD DUP2 JUMP JUMPDEST DUP1 PUSH1 0x3 DUP2 SWAP1 SSTORE POP DUP2 PUSH1 0x4 DUP2 SWAP1 SSTORE POP POP POP JUMP JUMPDEST PUSH1 0x3 SLOAD DUP2 JUMP JUMPDEST PUSH1 0x2 PUSH1 0x20 MSTORE DUP1 PUSH1 0x0 MSTORE PUSH1 0x40 PUSH1 0x0 KECCAK256 PUSH1 0x0 SWAP2 POP SWAP1 POP SLOAD DUP2 JUMP JUMPDEST PUSH1 0x0 DUP1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH4 0x4000AEA0 PUSH1 0x1 PUSH1 0x0 SWAP1 SLOAD SWAP1 PUSH2 0x100 EXP SWAP1 DIV PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP6 DUP8 DUP7 PUSH1 0x40 MLOAD PUSH1 0x20 ADD DUP1 DUP4 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE PUSH1 0x40 MLOAD DUP5 PUSH4 0xFFFFFFFF AND PUSH1 0xE0 SHL DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP5 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP4 DUP2 MSTORE PUSH1 0x20 ADD DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE DUP4 DUP2 DUP2 MLOAD DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 DUP1 DUP4 DUP4 PUSH1 0x0 JUMPDEST DUP4 DUP2 LT ISZERO PUSH2 0x2AF JUMPI DUP1 DUP3 ADD MLOAD DUP2 DUP5 ADD MSTORE PUSH1 0x20 DUP2 ADD SWAP1 POP PUSH2 0x294 JUMP JUMPDEST POP POP POP POP SWAP1 POP SWAP1 DUP2 ADD SWAP1 PUSH1 0x1F AND DUP1 ISZERO PUSH2 0x2DC JUMPI DUP1 DUP3 SUB DUP1 MLOAD PUSH1 0x1 DUP4 PUSH1 0x20 SUB PUSH2 0x100 EXP SUB NOT AND DUP2 MSTORE PUSH1 0x20 ADD SWAP2 POP JUMPDEST POP SWAP5 POP POP POP POP POP PUSH1 0x20 PUSH1 0x40 MLOAD DUP1 DUP4 SUB DUP2 PUSH1 0x0 DUP8 DUP1 EXTCODESIZE ISZERO DUP1 ISZERO PUSH2 0x2FD JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST POP GAS CALL ISZERO DUP1 ISZERO PUSH2 0x311 JUMPI RETURNDATASIZE PUSH1 0x0 DUP1 RETURNDATACOPY RETURNDATASIZE PUSH1 0x0 REVERT JUMPDEST POP POP POP POP PUSH1 0x40 MLOAD RETURNDATASIZE PUSH1 0x20 DUP2 LT ISZERO PUSH2 0x327 JUMPI PUSH1 0x0 DUP1 REVERT JUMPDEST DUP2 ADD SWAP1 DUP1 DUP1 MLOAD SWAP1 PUSH1 0x20 ADD SWAP1 SWAP3 SWAP2 SWAP1 POP POP POP POP PUSH1 0x0 PUSH2 0x35A DUP6 DUP5 ADDRESS PUSH1 0x2 PUSH1 0x0 DUP11 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD PUSH2 0x3AE JUMP JUMPDEST SWAP1 POP PUSH2 0x383 PUSH1 0x1 PUSH1 0x2 PUSH1 0x0 DUP9 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 SLOAD PUSH2 0x428 SWAP1 SWAP2 SWAP1 PUSH4 0xFFFFFFFF AND JUMP JUMPDEST PUSH1 0x2 PUSH1 0x0 DUP8 DUP2 MSTORE PUSH1 0x20 ADD SWAP1 DUP2 MSTORE PUSH1 0x20 ADD PUSH1 0x0 KECCAK256 DUP2 SWAP1 SSTORE POP PUSH2 0x3A4 DUP6 DUP3 PUSH2 0x4B0 JUMP JUMPDEST SWAP2 POP POP SWAP4 SWAP3 POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP5 DUP5 DUP5 DUP5 PUSH1 0x40 MLOAD PUSH1 0x20 ADD DUP1 DUP6 DUP2 MSTORE PUSH1 0x20 ADD DUP5 DUP2 MSTORE PUSH1 0x20 ADD DUP4 PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND PUSH20 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF AND DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP5 POP POP POP POP POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE DUP1 MLOAD SWAP1 PUSH1 0x20 ADD KECCAK256 PUSH1 0x0 SHR SWAP1 POP SWAP5 SWAP4 POP POP POP POP JUMP JUMPDEST PUSH1 0x0 DUP1 DUP3 DUP5 ADD SWAP1 POP DUP4 DUP2 LT ISZERO PUSH2 0x4A6 JUMPI PUSH1 0x40 MLOAD PUSH32 0x8C379A000000000000000000000000000000000000000000000000000000000 DUP2 MSTORE PUSH1 0x4 ADD DUP1 DUP1 PUSH1 0x20 ADD DUP3 DUP2 SUB DUP3 MSTORE PUSH1 0x1B DUP2 MSTORE PUSH1 0x20 ADD DUP1 PUSH32 0x536166654D6174683A206164646974696F6E206F766572666C6F770000000000 DUP2 MSTORE POP PUSH1 0x20 ADD SWAP2 POP POP PUSH1 0x40 MLOAD DUP1 SWAP2 SUB SWAP1 REVERT JUMPDEST DUP1 SWAP2 POP POP SWAP3 SWAP2 POP POP JUMP JUMPDEST PUSH1 0x0 DUP3 DUP3 PUSH1 0x40 MLOAD PUSH1 0x20 ADD DUP1 DUP4 DUP2 MSTORE PUSH1 0x20 ADD DUP3 DUP2 MSTORE PUSH1 0x20 ADD SWAP3 POP POP POP PUSH1 0x40 MLOAD PUSH1 0x20 DUP2 DUP4 SUB SUB DUP2 MSTORE SWAP1 PUSH1 0x40 MSTORE DUP1 MLOAD SWAP1 PUSH1 0x20 ADD KECCAK256 SWAP1 POP SWAP3 SWAP2 POP POP JUMP INVALID LOG2 PUSH5 0x6970667358 0x22 SLT KECCAK256 MLOAD REVERT PUSH10 0xBC7C1E79C55D6A3B309E 0x26 SWAP10 0xDA 0xA5 0xAD PUSH14 0x3024390148DAF54DDCF77A388A64 PUSH20 0x6F6C634300060200330000000000000000000000 ",
				"sourceMap": "137:443:31:-:0;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;137:443:31;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;217:24;;;:::i;:::-;;;;;;;;;;;;;;;;;;;417:161;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;417:161:31;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;182:31;;;:::i;:::-;;;;;;;;;;;;;;;;;;;6614:67:7;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;6614:67:7;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;5747:656;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;5747:656:7;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;217:24:31;;;;:::o;417:161::-;534:11;515:16;:30;;;;563:10;551:9;:22;;;;417:161;;:::o;182:31::-;;;;:::o;6614:67:7:-;;;;;;;;;;;;;;;;;:::o;5747:656::-;5841:17;5868:4;;;;;;;;;;;:20;;;5889:14;;;;;;;;;;;5905:4;5922:8;5932:5;5911:27;;;;;;;;;;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;5911:27:7;;;5868:71;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;23:1:-1;8:100;33:3;30:1;27:10;8:100;;;99:1;94:3;90:11;84:18;80:1;75:3;71:11;64:39;52:2;49:1;45:10;40:15;;8:100;;;12:14;5868:71:7;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;8:9:-1;5:2;;;30:1;27;20:12;5:2;5868:71:7;;;;8:9:-1;5:2;;;45:16;42:1;39;24:38;77:16;74:1;67:27;5:2;5868:71:7;;;;;;;13:2:-1;8:3;5:11;2:2;;;29:1;26;19:12;2:2;5868:71:7;;;;;;;;;;;;;;;;;6014:15;6033:66;6050:8;6060:5;6075:4;6082:6;:16;6089:8;6082:16;;;;;;;;;;;;6033;:66::i;:::-;6014:85;;6329:23;6350:1;6329:6;:16;6336:8;6329:16;;;;;;;;;;;;:20;;:23;;;;:::i;:::-;6310:6;:16;6317:8;6310:16;;;;;;;;;;;:42;;;;6366:32;6380:8;6390:7;6366:13;:32::i;:::-;6359:39;;;5747:656;;;;;:::o;1094:231:9:-;1224:7;1278:8;1288:9;1299:10;1311:6;1267:51;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;1267:51:9;;;1257:62;;;;;;1249:71;;1241:79;;1094:231;;;;;;:::o;822:162:38:-;880:7;895:9;911:1;907;:5;895:17;;931:1;926;:6;;918:46;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;978:1;971:8;;;822:162;;;;:::o;1705:171:9:-;1797:7;1846:8;1856:13;1829:41;;;;;;;;;;;;;;;;;;;;;49:4:-1;39:7;30;26:21;22:32;13:7;6:49;1829:41:9;;;1819:52;;;;;;1812:59;;1705:171;;;;:::o"
			},
			"methodIdentifiers": {
				"fulfillRandomness(bytes32,uint256)": "1f1f897f",
				"nonces(bytes32)": "9e317f12",
				"randomnessOutput()": "2f47fd86",
				"requestId()": "006d6cae",
				"requestRandomness(bytes32,uint256,uint256)": "dc6cfe10"
			}
		},
		"metadata": "{\"compiler\":{\"version\":\"0.6.2+commit.bacdbe57\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_vrfCoordinator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_link\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_requestId\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_randomness\",\"type\":\"uint256\"}],\"name\":\"fulfillRandomness\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"nonces\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"randomnessOutput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"requestId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"_keyHash\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"_fee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"requestRandomness\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"requestId\",\"type\":\"bytes32\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"methods\":{\"requestRandomness(bytes32,uint256,uint256)\":{\"details\":\"The source of the seed data must be something which the oraclecannot anticipate. See \\\"SECURITY CONSIDERATIONS\\\" above.The fulfillRandomness method receives the output, once it's providedby the Oracle, and verified by the vrfCoordinator.The _keyHash must already be registered with the VRFCoordinator, andthe _fee must exceed the fee specified during registration of the_keyHash.The returned requestId can be used to distinguish responses to *concurrent requests. It is passed as the first argument tofulfillRandomness.\",\"params\":{\"_fee\":\"The amount of LINK to send with the request\",\"_keyHash\":\"ID of public key against which randomness is generated\",\"_seed\":\"Random seed from which output randomness is determined\"},\"returns\":{\"requestId\":\"which will be returned with the response to this request\"}}}},\"userdoc\":{\"methods\":{\"requestRandomness(bytes32,uint256,uint256)\":{\"notice\":\"requestRandomness initiates a request for VRF output given _seed\"}}}},\"settings\":{\"compilationTarget\":{\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/tests/VRFConsumer.sol\":\"VRFConsumer\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/VRF.sol\":{\"keccak256\":\"0xfb21a49da78ea7ea7c371027608a74e1817006c23e9ccbe865230ed00b8a0dd4\",\"urls\":[\"bzz-raw://623742dffd5c55cc0d3e0a185c6e2e9fbda83272d63bbe89a11145a8ff09113d\",\"dweb:/ipfs/QmbiSvzL5ijbx1iVq4qVRJMr4ZNxDvDgmNjMToHgG2WaXt\"]},\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/VRFConsumerBase.sol\":{\"keccak256\":\"0xe3780908c7cefe398d20ad2ff82c8648f91ae886cdb8f78813576340d0baf6a1\",\"urls\":[\"bzz-raw://00dbff4e17f11dbf59c403ef8992fbad0dbd0c70bc60fc760593702e7501b55a\",\"dweb:/ipfs/QmbtST2wX72mmwmvhA7FgKtAub89TBeVeb8F5eSyd6p2Ak\"]},\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/VRFCoordinator.sol\":{\"keccak256\":\"0x0bbc5880836a4437846b0e7f33ee33a483bf752a5569e424b8c19f964d64bd28\",\"urls\":[\"bzz-raw://c35ea64b2bcb0920601cb06041e8d00a06a561da1f225f5472aa38618ce0bc74\",\"dweb:/ipfs/QmR3QbsP2cy9MZsCyNYXWWZAUx8HNgb4PBdaN5NwgXKMxk\"]},\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/VRFRequestIDBase.sol\":{\"keccak256\":\"0x0c431760785b5f5b9847fb51ba7e62a3439810e7d8dcbde8247e804f25e6fd21\",\"urls\":[\"bzz-raw://f4c4a572b4681fc118b3db8604f62fb747e9c7dbc19d34aa39f92243b043aeaa\",\"dweb:/ipfs/QmegohMUPgG3NMsn3jAyEE5JUpFsDL7JdJ3LG9bRfY28SF\"]},\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/interfaces/LinkTokenInterface.sol\":{\"keccak256\":\"0xdbf46b45a4c9f38ba71a0391aed0e7b108854b619f292d907ae537228868bda6\",\"urls\":[\"bzz-raw://3ae40466809630c4731e2e3a697d6885727c577aaf260766c8a2f534ad3f6ee8\",\"dweb:/ipfs/QmTzpN5yP4Y5jvQ1ohfXFrce3sjzUiSChYJgZj9VvhVohG\"]},\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/tests/VRFConsumer.sol\":{\"keccak256\":\"0xa7e68a6262cbf27d8ce637b84464e53000fd349a21790bf59452b80bd8f4f20f\",\"urls\":[\"bzz-raw://c99643f905faa539565dcab288ba69e9eb7a8ef6e1035da19544d99ca823ef83\",\"dweb:/ipfs/Qmb7kBXtveHTR72kcNT5sYFYPkgWtAYUqBJMnnFM8yjWnc\"]},\"/Users/bartosz/localhost/chainlink/evm-contracts/src/v0.6/vendor/SafeMath.sol\":{\"keccak256\":\"0x95dbe2dd5ab8682b99bc3d7d297b621d4237442da160f78d3323ee5c4a06ded3\",\"urls\":[\"bzz-raw://d753308ff4eb43fba6f9ede371a33f707c5818350770dcb078a7d78ac8251361\",\"dweb:/ipfs/Qme64eYKWoTQiP3WhqGHoMqrENNZ9L8SdBLQ2hx5SmzUda\"]}},\"version\":1}",
		"userdoc": {
			"methods": {
				"requestRandomness(bytes32,uint256,uint256)": {
					"notice": "requestRandomness initiates a request for VRF output given _seed"
				}
			}
		}
	},
	"sources": {
		"tests/VRFConsumer.sol": {
			"id": 31
		},
		"interfaces/LinkTokenInterface.sol": {
			"id": 23
		},
		"VRFCoordinator.sol": {
			"id": 8
		},
		"vendor/SafeMath.sol": {
			"id": 38
		},
		"VRF.sol": {
			"id": 6
		},
		"VRFRequestIDBase.sol": {
			"id": 9
		},
		"VRFConsumerBase.sol": {
			"id": 7
		}
	},
	"sourceCodes": {
		"tests/VRFConsumer.sol": "pragma solidity 0.6.2;\n\nimport \"../interfaces/LinkTokenInterface.sol\";\nimport \"../VRFCoordinator.sol\";\nimport \"../VRFConsumerBase.sol\";\n\ncontract VRFConsumer is VRFConsumerBase {\n\n  uint256 public randomnessOutput;\n  bytes32 public requestId;\n\n  constructor(address _vrfCoordinator, address _link) public\n    // solhint-disable-next-line no-empty-blocks\n    VRFConsumerBase(_vrfCoordinator, _link) { /* empty */ }\n\n  function fulfillRandomness(bytes32 _requestId, uint256 _randomness)\n    external override\n  {\n    randomnessOutput = _randomness;\n    requestId = _requestId;\n  }\n}\n",
		"interfaces/LinkTokenInterface.sol": "pragma solidity ^0.6.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n  function approve(address spender, uint256 value) external returns (bool success);\n  function balanceOf(address owner) external view returns (uint256 balance);\n  function decimals() external view returns (uint8 decimalPlaces);\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n  function name() external view returns (string memory tokenName);\n  function symbol() external view returns (string memory tokenSymbol);\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n  function transfer(address to, uint256 value) external returns (bool success);\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n",
		"VRFCoordinator.sol": "pragma solidity 0.6.2;\n\nimport \"./vendor/SafeMath.sol\";\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRF.sol\";\nimport \"./VRFRequestIDBase.sol\";\nimport \"./VRFConsumerBase.sol\";\n\n/**\n * @title VRFCoordinator coordinates on-chain verifiable-randomness requests\n * @title with off-chain responses\n */\ncontract VRFCoordinator is VRF, VRFRequestIDBase {\n\n  using SafeMath for uint256;\n\n  LinkTokenInterface internal LINK;\n\n  constructor(address _link) public {\n    LINK = LinkTokenInterface(_link);\n  }\n\n  struct Callback { // Tracks an ongoing request\n    address callbackContract; // Requesting contract, which will receive response\n    uint256 randomnessFee; // Amount of LINK paid at request time\n    // Seed for the *oracle* to use in generating this random value. It is the\n    // hash of the seed provided as input during a randomnessRequest, plus the\n    // address of the contract making the request, plus an increasing nonce\n    // specific to the VRF proving key and the calling contract. Including this\n    // extra data in the VRF input seed helps to prevent unauthorized queries\n    // against a VRF by any party who has prior knowledge of the requester's\n    // prospective seed. Only the specified contract can make that request.\n    uint256 seed;\n  }\n\n  struct ServiceAgreement { // Tracks oracle commitments to VRF service\n    address vRFOracle; // Oracle committing to respond with VRF service\n    bytes32 jobID; // ID of corresponding chainlink job in oracle's DB\n    uint256 fee; // Minimum payment for oracle response\n  }\n\n  mapping(bytes32 /* (provingKey, seed) */ => Callback) public callbacks;\n  mapping(bytes32 /* provingKey */ => ServiceAgreement)\n    public serviceAgreements;\n  mapping(address /* oracle */ => uint256 /* LINK balance */)\n    public withdrawableTokens;\n  mapping(bytes32 /* provingKey */ => mapping(address /* consumer */ => uint256))\n    private nonces;\n\n  // The oracle only needs the jobID to look up the VRF, but specifying public\n  // key as well prevents a malicious oracle from inducing VRF outputs from\n  // another oracle by reusing the jobID.\n  event RandomnessRequest(\n    bytes32 keyHash,\n    uint256 seed,\n    bytes32 indexed jobID,\n    address sender,\n    uint256 fee);\n\n  event NewServiceAgreement(bytes32 keyHash, uint256 fee);\n\n  /**\n   * @notice Commits calling address to serve randomness\n   * @param _fee minimum LINK payment required to serve randomness\n   * @param _publicProvingKey public key used to prove randomness\n   * @param _jobID ID of the corresponding chainlink job in the oracle's db\n   */\n  function registerProvingKey(\n    uint256 _fee, uint256[2] calldata _publicProvingKey, bytes32 _jobID\n  )\n    external\n  {\n    bytes32 keyHash = hashOfKey(_publicProvingKey);\n    address oldVRFOracle = serviceAgreements[keyHash].vRFOracle;\n    require(oldVRFOracle == address(0), \"please register a new key\");\n    serviceAgreements[keyHash].vRFOracle = msg.sender;\n    serviceAgreements[keyHash].jobID = _jobID;\n    serviceAgreements[keyHash].fee = _fee;\n    emit NewServiceAgreement(keyHash, _fee);\n  }\n\n  /**\n   * @notice Called by LINK.transferAndCall, on successful LINK transfer\n   *\n   * @dev To invoke this, use the requestRandomness method in VRFConsumerBase.\n   *\n   * @dev The VRFCoordinator will call back to the calling contract when the\n   * @dev oracle responds, on the method fulfillRandomness. See\n   * @dev VRFConsumerBase.fullfilRandomnessRequest for its signature. Your\n   * @dev consuming contract should inherit from VRFConsumerBase, and implement\n   * @dev fullfilRandomnessRequest.\n   *\n   * @param _sender address: who sent the LINK (must be a contract)\n   * @param _fee amount of LINK sent\n   * @param _data abi-encoded call to randomnessRequest\n   */\n  function onTokenTransfer(address _sender, uint256 _fee, bytes memory _data)\n    public\n    onlyLINK\n  {\n    (bytes32 keyHash, uint256 seed) = abi.decode(_data, (bytes32, uint256));\n    randomnessRequest(keyHash, seed, _fee, _sender);\n  }\n\n  /**\n   * @notice creates the chainlink request for randomness\n   *\n   * @param _keyHash ID of the VRF public key against which to generate output\n   * @param _seed Input to the VRF, from which randomness is generated\n   * @param _feePaid Amount of LINK sent with request. Must exceed fee for key\n   * @param _sender Requesting contract; to be called back with VRF output\n   */\n  function randomnessRequest(\n    bytes32 _keyHash,\n    uint256 _seed,\n    uint256 _feePaid,\n    address _sender\n  )\n    internal\n    sufficientLINK(_feePaid, _keyHash)\n  {\n    uint256 nonce = nonces[_keyHash][_sender];\n    uint256 seed = makeVRFInputSeed(_keyHash, _seed, _sender, nonce);\n    bytes32 requestId = makeRequestId(_keyHash, seed);\n    // Cryptographically guaranteed by seed including an increasing nonce\n    assert(callbacks[requestId].callbackContract == address(0));\n    callbacks[requestId].callbackContract = _sender;\n    callbacks[requestId].randomnessFee = _feePaid;\n    callbacks[requestId].seed = seed;\n    emit RandomnessRequest(_keyHash, seed, serviceAgreements[_keyHash].jobID,\n      _sender, _feePaid);\n    nonces[_keyHash][_sender] = nonces[_keyHash][_sender].add(1);\n  }\n\n  /**\n   * @notice Called by the chainlink node to fullfil requests\n   * @param _proof the proof of randomness. Actual random output built from this\n   *\n   * @dev This is the main entrypoint for chainlink. If you change this, you\n   * @dev should also change the solidityABISstring in solidity_proof.go.\n   */\n  function fulfillRandomnessRequest(bytes memory _proof) public returns (bool) {\n    // TODO(alx): Replace the public key in the above proof with an argument\n    // specifying the keyHash. Splice the key in here before sending it to\n    // VRF.sol. Should be able to save about 2,000 gas that way.\n    // https://www.pivotaltracker.com/story/show/170828567\n    //\n    // TODO(alx): Move this parsing into VRF.sol, where the bytes layout is recorded.\n    // https://www.pivotaltracker.com/story/show/170828697\n    uint256[2] memory publicKey;\n    uint256 seed;\n    // solhint-disable-next-line no-inline-assembly\n    assembly { // Extract the public key and seed from proof\n      publicKey := add(_proof, 0x20) // Skip length word for first 64 bytes\n      seed := mload(add(_proof, 0xe0)) // Seed is 7th word in proof, plus word for length\n    }\n    bytes32 currentKeyHash = hashOfKey(publicKey);\n    bytes32 requestId = makeRequestId(currentKeyHash, seed);\n    Callback memory callback = callbacks[requestId];\n    require(callback.callbackContract != address(0), \"no corresponding request\");\n    uint256 randomness = VRF.randomValueFromVRFProof(_proof); // Reverts on failure\n    address oadd = serviceAgreements[currentKeyHash].vRFOracle;\n    withdrawableTokens[oadd] = withdrawableTokens[oadd].add(callback.randomnessFee);\n    // Dummy variable; allows access to method selector in next line. See\n    // https://github.com/ethereum/solidity/issues/3506#issuecomment-553727797\n    VRFConsumerBase v;\n    bytes memory resp = abi.encodeWithSelector(\n      v.fulfillRandomness.selector, requestId, randomness);\n    // solhint-disable-next-line avoid-low-level-calls\n    (bool success,) = callback.callbackContract.call(resp);\n    delete callbacks[requestId]; // Be a good ethereum citizen\n    return success;\n  }\n\n  /**\n   * @dev Allows the oracle operator to withdraw their LINK\n   * @param _recipient is the address the funds will be sent to\n   * @param _amount is the amount of LINK transfered from the Coordinator contract\n   */\n  function withdraw(address _recipient, uint256 _amount)\n    external\n    hasAvailableFunds(_amount)\n  {\n    withdrawableTokens[msg.sender] = withdrawableTokens[msg.sender].sub(_amount);\n    assert(LINK.transfer(_recipient, _amount));\n  }\n\n  /**\n   * @notice Returns the serviceAgreements key associated with this public key\n   * @param _publicKey the key to return the address for\n   */\n  function hashOfKey(uint256[2] memory _publicKey) public pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_publicKey));\n  }\n\n  /**\n   * @dev Reverts if amount is not at least what was agreed upon in the service agreement\n   * @param _feePaid The payment for the request\n   * @param _keyHash The key which the request is for\n   */\n  modifier sufficientLINK(uint256 _feePaid, bytes32 _keyHash) {\n    require(_feePaid >= serviceAgreements[_keyHash].fee, \"Below agreed payment\");\n    _;\n  }\n\n/**\n   * @dev Reverts if not sent from the LINK token\n   */\n  modifier onlyLINK() {\n    require(msg.sender == address(LINK), \"Must use LINK token\");\n    _;\n  }\n\n  /**\n   * @dev Reverts if amount requested is greater than withdrawable balance\n   * @param _amount The given amount to compare to `withdrawableTokens`\n   */\n  modifier hasAvailableFunds(uint256 _amount) {\n    require(withdrawableTokens[msg.sender] >= _amount, \"can't withdraw more than balance\");\n    _;\n  }\n\n}\n",
		"vendor/SafeMath.sol": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n    * @dev Returns the addition of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `+` operator.\n    *\n    * Requirements:\n    * - Addition cannot overflow.\n    */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the subtraction of two unsigned integers, reverting on\n    * overflow (when the result is negative).\n    *\n    * Counterpart to Solidity's `-` operator.\n    *\n    * Requirements:\n    * - Subtraction cannot overflow.\n    */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a, \"SafeMath: subtraction overflow\");\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the multiplication of two unsigned integers, reverting on\n    * overflow.\n    *\n    * Counterpart to Solidity's `*` operator.\n    *\n    * Requirements:\n    * - Multiplication cannot overflow.\n    */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the integer division of two unsigned integers. Reverts on\n    * division by zero. The result is rounded towards zero.\n    *\n    * Counterpart to Solidity's `/` operator. Note: this function uses a\n    * `revert` opcode (which leaves remaining gas untouched) while Solidity\n    * uses an invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, \"SafeMath: division by zero\");\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n    * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n    * Reverts when dividing by zero.\n    *\n    * Counterpart to Solidity's `%` operator. This function uses a `revert`\n    * opcode (which leaves remaining gas untouched) while Solidity uses an\n    * invalid opcode to revert (consuming all remaining gas).\n    *\n    * Requirements:\n    * - The divisor cannot be zero.\n    */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0, \"SafeMath: modulo by zero\");\n    return a % b;\n  }\n}\n",
		"VRF.sol": "pragma solidity 0.6.2;\n\n/** ****************************************************************************\n  * @notice Verification of verifiable-random-function (VRF) proofs, following\n  * @notice https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\n  * @notice See https://eprint.iacr.org/2017/099.pdf for security proofs.\n\n  * @dev Bibliographic references:\n\n  * @dev Goldberg, et al., \"Verifiable Random Functions (VRFs)\", Internet Draft\n  * @dev draft-irtf-cfrg-vrf-05, IETF, Aug 11 2019,\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05\n\n  * @dev Papadopoulos, et al., \"Making NSEC5 Practical for DNSSEC\", Cryptology\n  * @dev ePrint Archive, Report 2017/099, https://eprint.iacr.org/2017/099.pdf\n  * ****************************************************************************\n  * @dev USAGE\n\n  * @dev The main entry point is randomValueFromVRFProof. See its docstring.\n  * ****************************************************************************\n  * @dev PURPOSE\n\n  * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n  * @dev to Vera the verifier in such a way that Vera can be sure he's not\n  * @dev making his output up to suit himself. Reggie provides Vera a public key\n  * @dev to which he knows the secret key. Each time Vera provides a seed to\n  * @dev Reggie, he gives back a value which is computed completely\n  * @dev deterministically from the seed and the secret key.\n\n  * @dev Reggie provides a proof by which Vera can verify that the output was\n  * @dev correctly computed once Reggie tells it to her, but without that proof,\n  * @dev the output is computationally indistinguishable to her from a uniform\n  * @dev random sample from the output space.\n\n  * @dev The purpose of this contract is to perform that verification.\n  * ****************************************************************************\n  * @dev DESIGN NOTES\n\n  * @dev The VRF algorithm verified here satisfies the full unqiqueness, full\n  * @dev collision resistance, and full pseudorandomness security properties.\n  * @dev See \"SECURITY PROPERTIES\" below, and\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-3\n\n  * @dev An elliptic curve point is generally represented in the solidity code\n  * @dev as a uint256[2], corresponding to its affine coordinates in\n  * @dev GF(FIELD_SIZE).\n\n  * @dev For the sake of efficiency, this implementation deviates from the spec\n  * @dev in some minor ways:\n\n  * @dev - Keccak hash rather than the SHA256 hash recommended in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\n  * @dev   Keccak costs much less gas on the EVM, and provides similar security.\n\n  * @dev - Secp256k1 curve instead of the P-256 or ED25519 curves recommended in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5\n  * @dev   For curve-point multiplication, it's much cheaper to abuse ECRECOVER\n\n  * @dev - hashToCurve recursively hashes until it finds a curve x-ordinate. On\n  * @dev   the EVM, this is slightly more efficient than the recommendation in\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\n  * @dev   step 5, to concatenate with a nonce then hash, and rehash with the\n  * @dev   nonce updated until a valid x-ordinate is found.\n\n  * @dev - hashToCurve does not include a cipher version string or the byte 0x1\n  * @dev   in the hash message, as recommended in step 5.B of the draft\n  * @dev   standard. They are unnecessary here because no variation in the\n  * @dev   cipher suite is allowed.\n\n  * @dev - Similarly, the hash input in scalarFromCurvePoints does not include a\n  * @dev   commitment to the cipher suite, either, which differs from step 2 of\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\n  * @dev   . Also, the hash input is the concatenation of the uncompressed\n  * @dev   points, not the compressed points as recommended in step 3.\n\n  * @dev - In the calculation of the challenge value \"c\", the \"u\" value (i.e.\n  * @dev   the value computed by Reggie as the nonce times the secp256k1\n  * @dev   generator point, see steps 5 and 7 of\n  * @dev   https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.3\n  * @dev   ) is replaced by its ethereum address, i.e. the lower 160 bits of the\n  * @dev   keccak hash of the original u. This is because we only verify the\n  * @dev   calculation of u up to its address, by abusing ECRECOVER.\n  * ****************************************************************************\n  * @dev   SECURITY PROPERTIES\n\n  * @dev Here are the security properties for this VRF:\n\n  * @dev Full uniqueness: For any seed and valid VRF public key, there is\n  * @dev   exactly one VRF output which can be proved to come from that seed, in\n  * @dev   the sense that the proof will pass verifyVRFProof.\n\n  * @dev Full collision resistance: It's cryptographically infeasible to find\n  * @dev   two seeds with same VRF output from a fixed, valid VRF key\n\n  * @dev Full pseudorandomness: Absent the proofs that the VRF outputs are\n  * @dev   derived from a given seed, the outputs are computationally\n  * @dev   indistinguishable from randomness.\n\n  * @dev https://eprint.iacr.org/2017/099.pdf, Appendix B contains the proofs\n  * @dev for these properties.\n\n  * @dev For secp256k1, the key validation described in section\n  * @dev https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.6\n  * @dev is unnecessary, because secp256k1 has cofactor 1, and the\n  * @dev representation of the public key used here (affine x- and y-ordinates\n  * @dev of the secp256k1 point on the standard y^2=x^3+7 curve) cannot refer to\n  * @dev the point at infinity.\n  * ****************************************************************************\n  * @dev OTHER SECURITY CONSIDERATIONS\n  *\n  * @dev The seed input to the VRF could in principle force an arbitrary amount\n  * @dev of work in hashToCurve, by requiring extra rounds of hashing and\n  * @dev checking whether that's yielded the x ordinate of a secp256k1 point.\n  * @dev However, under the Random Oracle Model the probability of choosing a\n  * @dev point which forces n extra rounds in hashToCurve is 2. The base cost\n  * @dev for calling hashToCurve is about 25,000 gas, and each round of checking\n  * @dev for a valid x ordinate costs about 15,555 gas, so to find a seed for\n  * @dev which hashToCurve would cost more than 2,017,000 gas, one would have to\n  * @dev try, in expectation, about 2 seeds, which is infeasible for any\n  * @dev forseeable computational resources. (25,000 + 128 * 15,555 < 2,017,000.)\n\n  * @dev Since the gas block limit for the Ethereum main net is 10,000,000 gas,\n  * @dev this means it is infeasible for an adversary to prevent correct\n  * @dev operation of this contract by choosing an adverse seed.\n\n  * @dev (See TestMeasureHashToCurveGasCost for verification of the gas cost for\n  * @dev hashToCurve.)\n\n  * @dev It may be possible to make a secure constant-time hashToCurve function.\n  * @dev See notes in hashToCurve docstring.\n*/\ncontract VRF {\n\n  // See https://www.secg.org/sec2-v2.pdf, section 2.4.1, for these constants.\n  uint256 constant private GROUP_ORDER = // Number of points in Secp256k1\n    // solium-disable-next-line indentation\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n  // Prime characteristic of the galois field over which Secp256k1 is defined\n  uint256 constant private FIELD_SIZE =\n    // solium-disable-next-line indentation\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\n  uint256 constant private WORD_LENGTH_BYTES = 0x20;\n\n  // (base^exponent) % FIELD_SIZE\n  // Cribbed from https://medium.com/@rbkhmrcr/precompiles-solidity-e5d29bd428c4\n  function bigModExp(uint256 base, uint256 exponent)\n    internal view returns (uint256 exponentiation) {\n      uint256 callResult;\n      uint256[6] memory bigModExpContractInputs;\n      bigModExpContractInputs[0] = WORD_LENGTH_BYTES;  // Length of base\n      bigModExpContractInputs[1] = WORD_LENGTH_BYTES;  // Length of exponent\n      bigModExpContractInputs[2] = WORD_LENGTH_BYTES;  // Length of modulus\n      bigModExpContractInputs[3] = base;\n      bigModExpContractInputs[4] = exponent;\n      bigModExpContractInputs[5] = FIELD_SIZE;\n      uint256[1] memory output;\n      assembly { // solhint-disable-line no-inline-assembly\n      callResult := staticcall(\n        not(0),                   // Gas cost: no limit\n        0x05,                     // Bigmodexp contract address\n        bigModExpContractInputs,\n        0xc0,                     // Length of input segment: 6*0x20-bytes\n        output,\n        0x20                      // Length of output segment\n      )\n      }\n      if (callResult == 0) {revert(\"bigModExp failure!\");}\n      return output[0];\n    }\n\n  // Let q=FIELD_SIZE. q % 4 = 3,  xr^2 mod q  x^SQRT_POWERr mod q.  See\n  // https://en.wikipedia.org/wiki/Modular_square_root#Prime_or_prime_power_modulus\n  uint256 constant private SQRT_POWER = (FIELD_SIZE + 1) >> 2;\n\n  // Computes a s.t. a^2 = x in the field. Assumes a exists\n  function squareRoot(uint256 x) internal view returns (uint256) {\n    return bigModExp(x, SQRT_POWER);\n  }\n\n  // The value of y^2 given that (x,y) is on secp256k1.\n  function ySquared(uint256 x) internal pure returns (uint256) {\n    // Curve is y^2=x^3+7. See section 2.4.1 of https://www.secg.org/sec2-v2.pdf\n    uint256 xCubed = mulmod(x, mulmod(x, x, FIELD_SIZE), FIELD_SIZE);\n    return addmod(xCubed, 7, FIELD_SIZE);\n  }\n\n  // True iff p is on secp256k1\n  function isOnCurve(uint256[2] memory p) internal pure returns (bool) {\n    return ySquared(p[0]) == mulmod(p[1], p[1], FIELD_SIZE);\n  }\n\n  // Hash x uniformly into {0, ..., FIELD_SIZE-1}.\n  function fieldHash(bytes memory b) internal pure returns (uint256 x_) {\n    x_ = uint256(keccak256(b));\n    // Rejecting if x >= FIELD_SIZE corresponds to step 2.1 in section 2.3.4 of\n    // http://www.secg.org/sec1-v2.pdf , which is part of the definition of\n    // string_to_point in the IETF draft\n    while (x_ >= FIELD_SIZE) {\n      x_ = uint256(keccak256(abi.encodePacked(x_)));\n    }\n  }\n\n  // Hash b to a random point which hopefully lies on secp256k1. The y ordinate\n  // is always even, due to\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.1.1\n  // step 5.C, which references arbitrary_string_to_point, defined in\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.5 as\n  // returning the point with given x ordinate, and even y ordinate.\n  function newCandidateSecp256k1Point(bytes memory b)\n    internal view returns (uint256[2] memory p) {\n      p[0] = fieldHash(b);\n      p[1] = squareRoot(ySquared(p[0]));\n      if (p[1] % 2 == 1) {\n        p[1] = FIELD_SIZE - p[1];\n      }\n    }\n\n  // Domain-separation tag for initial hash in hashToCurve. Corresponds to\n  // vrf.go/hashToCurveHashPrefix\n  uint256 constant HASH_TO_CURVE_HASH_PREFIX = 1;\n\n  // Cryptographic hash function onto the curve.\n  //\n  // Corresponds to algorithm in section 5.4.1.1 of the draft standard. (But see\n  // DESIGN NOTES above for slight differences.)\n  //\n  // TODO(alx): Implement a bounded-computation hash-to-curve, as described in\n  // \"Construction of Rational Points on Elliptic Curves over Finite Fields\"\n  // http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.831.5299&rep=rep1&type=pdf\n  // and suggested by\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-01#section-5.2.2\n  // (Though we can't used exactly that because secp256k1's j-invariant is 0.)\n  //\n  // This would greatly simplify the analysis in \"OTHER SECURITY CONSIDERATIONS\"\n  // https://www.pivotaltracker.com/story/show/171120900\n  function hashToCurve(uint256[2] memory pk, uint256 input)\n    internal view returns (uint256[2] memory rv) {\n      rv = newCandidateSecp256k1Point(abi.encodePacked(HASH_TO_CURVE_HASH_PREFIX,\n                                                       pk, input));\n      while (!isOnCurve(rv)) {\n        rv = newCandidateSecp256k1Point(abi.encodePacked(rv[0]));\n      }\n    }\n\n  /** *********************************************************************\n   * @notice Check that product==scalar*multiplicand\n   *\n   * @dev Based on Vitalik Buterin's idea in ethresear.ch post cited below.\n   *\n   * @param multiplicand: secp256k1 point\n   * @param scalar: non-zero GF(GROUP_ORDER) scalar\n   * @param product: secp256k1 expected to be mulitplier * multiplicand\n   * @return verifies true iff product==scalar*multiplicand, with cryptographically high probability\n   */\n  function ecmulVerify(uint256[2] memory multiplicand, uint256 scalar,\n    uint256[2] memory product) internal pure returns(bool verifies)\n  {\n    require(scalar != 0); // Rules out an ecrecover failure case\n    uint256 x = multiplicand[0]; // x ordinate of multiplicand\n    uint8 v = multiplicand[1] % 2 == 0 ? 27 : 28; // parity of y ordinate\n    // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n    // Point corresponding to address ecrecover(0, v, x, s=scalar*x) is\n    // (x mod GROUP_ORDER) * (scalar * x * multiplicand - 0 * g), i.e.\n    // scalar*multiplicand. See https://crypto.stackexchange.com/a/18106\n    bytes32 scalarTimesX = bytes32(mulmod(scalar, x, GROUP_ORDER));\n    address actual = ecrecover(bytes32(0), v, bytes32(x), scalarTimesX);\n    // Explicit conversion to address takes bottom 160 bits\n    address expected = address(uint256(keccak256(abi.encodePacked(product))));\n    return (actual == expected);\n  }\n\n  // Returns x1/z1-x2/z2=(x1z2-x2z1)/(z1z2) in projective coordinates on P()\n  function projectiveSub(uint256 x1, uint256 z1, uint256 x2, uint256 z2)\n    internal pure returns(uint256 x3, uint256 z3) {\n      uint256 num1 = mulmod(z2, x1, FIELD_SIZE);\n      uint256 num2 = mulmod(FIELD_SIZE - x2, z1, FIELD_SIZE);\n      (x3, z3) = (addmod(num1, num2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\n    }\n\n  // Returns x1/z1*x2/z2=(x1x2)/(z1z2), in projective coordinates on P()\n  function projectiveMul(uint256 x1, uint256 z1, uint256 x2, uint256 z2)\n    internal pure returns(uint256 x3, uint256 z3) {\n      (x3, z3) = (mulmod(x1, x2, FIELD_SIZE), mulmod(z1, z2, FIELD_SIZE));\n    }\n\n  /** **************************************************************************\n      @notice Computes elliptic-curve sum, in projective co-ordinates\n\n      @dev Using projective coordinates avoids costly divisions\n\n      @dev To use this with p and q in affine coordinates, call\n      @dev projectiveECAdd(px, py, qx, qy). This will return\n      @dev the addition of (px, py, 1) and (qx, qy, 1), in the\n      @dev secp256k1 group.\n\n      @dev This can be used to calculate the z which is the inverse to zInv\n      @dev in isValidVRFOutput. But consider using a faster\n      @dev re-implementation such as ProjectiveECAdd in the golang vrf package.\n\n      @dev This function assumes [px,py,1],[qx,qy,1] are valid projective\n           coordinates of secp256k1 points. That is safe in this contract,\n           because this method is only used by linearCombination, which checks\n           points are on the curve via ecrecover.\n      **************************************************************************\n      @param px The first affine coordinate of the first summand\n      @param py The second affine coordinate of the first summand\n      @param qx The first affine coordinate of the second summand\n      @param qy The second affine coordinate of the second summand\n\n      (px,py) and (qx,qy) must be distinct, valid secp256k1 points.\n      **************************************************************************\n      Return values are projective coordinates of [px,py,1]+[qx,qy,1] as points\n      on secp256k1, in P()\n      @return sx \n      @return sy\n      @return sz\n  */\n  function projectiveECAdd(uint256 px, uint256 py, uint256 qx, uint256 qy)\n    internal pure returns(uint256 sx, uint256 sy, uint256 sz) {\n      // See \"Group law for E/K : y^2 = x^3 + ax + b\", in section 3.1.2, p. 80,\n      // \"Guide to Elliptic Curve Cryptography\" by Hankerson, Menezes and Vanstone\n      // We take the equations there for (sx,sy), and homogenize them to\n      // projective coordinates. That way, no inverses are required, here, and we\n      // only need the one inverse in affineECAdd.\n\n      // We only need the \"point addition\" equations from Hankerson et al. Can\n      // skip the \"point doubling\" equations because p1 == p2 is cryptographically\n      // impossible, and require'd not to be the case in linearCombination.\n\n      // Add extra \"projective coordinate\" to the two points\n      (uint256 z1, uint256 z2) = (1, 1);\n\n      // (lx, lz) = (qy-py)/(qx-px), i.e., gradient of secant line.\n      uint256 lx = addmod(qy, FIELD_SIZE - py, FIELD_SIZE);\n      uint256 lz = addmod(qx, FIELD_SIZE - px, FIELD_SIZE);\n\n      uint256 dx; // Accumulates denominator from sx calculation\n      // sx=((qy-py)/(qx-px))^2-px-qx\n      (sx, dx) = projectiveMul(lx, lz, lx, lz); // ((qy-py)/(qx-px))^2\n      (sx, dx) = projectiveSub(sx, dx, px, z1); // ((qy-py)/(qx-px))^2-px\n      (sx, dx) = projectiveSub(sx, dx, qx, z2); // ((qy-py)/(qx-px))^2-px-qx\n\n      uint256 dy; // Accumulates denominator from sy calculation\n      // sy=((qy-py)/(qx-px))(px-sx)-py\n      (sy, dy) = projectiveSub(px, z1, sx, dx); // px-sx\n      (sy, dy) = projectiveMul(sy, dy, lx, lz); // ((qy-py)/(qx-px))(px-sx)\n      (sy, dy) = projectiveSub(sy, dy, py, z1); // ((qy-py)/(qx-px))(px-sx)-py\n\n      if (dx != dy) { // Cross-multiply to put everything over a common denominator\n        sx = mulmod(sx, dy, FIELD_SIZE);\n        sy = mulmod(sy, dx, FIELD_SIZE);\n        sz = mulmod(dx, dy, FIELD_SIZE);\n      } else { // Already over a common denominator, use that for z ordinate\n        sz = dx;\n      }\n    }\n\n  // p1+p2, as affine points on secp256k1.\n  //\n  // invZ must be the inverse of the z returned by projectiveECAdd(p1, p2).\n  // It is computed off-chain to save gas.\n  //\n  // p1 and p2 must be distinct, because projectiveECAdd doesn't handle\n  // point doubling.\n  function affineECAdd(\n    uint256[2] memory p1, uint256[2] memory p2,\n    uint256 invZ) internal pure returns (uint256[2] memory) {\n    uint256 x;\n    uint256 y;\n    uint256 z;\n    (x, y, z) = projectiveECAdd(p1[0], p1[1], p2[0], p2[1]);\n    require(mulmod(z, invZ, FIELD_SIZE) == 1, \"invZ must be inverse of z\");\n    // Clear the z ordinate of the projective representation by dividing through\n    // by it, to obtain the affine representation\n    return [mulmod(x, invZ, FIELD_SIZE), mulmod(y, invZ, FIELD_SIZE)];\n  }\n\n  // True iff address(c*p+s*g) == lcWitness, where g is generator. (With\n  // cryptographically high probability.)\n  function verifyLinearCombinationWithGenerator(\n    uint256 c, uint256[2] memory p, uint256 s, address lcWitness)\n    internal pure returns (bool) {\n      // Rule out ecrecover failure modes which return address 0.\n      require(lcWitness != address(0), \"bad witness\");\n      uint8 v = (p[1] % 2 == 0) ? 27 : 28; // parity of y-ordinate of p\n      bytes32 pseudoHash = bytes32(GROUP_ORDER - mulmod(p[0], s, GROUP_ORDER)); // -s*p[0]\n      bytes32 pseudoSignature = bytes32(mulmod(c, p[0], GROUP_ORDER)); // c*p[0]\n      // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n      // The point corresponding to the address returned by\n      // ecrecover(-s*p[0],v,p[0],c*p[0]) is\n      // (p[0] mod GROUP_ORDER)*(c*p[0]-(-s)*p[0]*g)=c*p+s*g.\n      // See https://crypto.stackexchange.com/a/18106\n      // https://bitcoin.stackexchange.com/questions/38351/ecdsa-v-r-s-what-is-v\n      address computed = ecrecover(pseudoHash, v, bytes32(p[0]), pseudoSignature);\n      return computed == lcWitness;\n    }\n\n  // c*p1 + s*p2. Requires cp1Witness=c*p1 and sp2Witness=s*p2. Also\n  // requires cp1Witness != sp2Witness (which is fine for this application,\n  // since it is cryptographically impossible for them to be equal. In the\n  // (cryptographically impossible) case that a prover accidentally derives\n  // a proof with equal c*p1 and s*p2, they should retry with a different\n  // proof nonce.) Assumes that all points are on secp256k1\n  // (which is checked in verifyVRFProof below.)\n  function linearCombination(\n    uint256 c, uint256[2] memory p1, uint256[2] memory cp1Witness,\n    uint256 s, uint256[2] memory p2, uint256[2] memory sp2Witness,\n    uint256 zInv)\n    internal pure returns (uint256[2] memory) {\n      require((cp1Witness[0] - sp2Witness[0]) % FIELD_SIZE != 0,\n              \"points in sum must be distinct\");\n      require(ecmulVerify(p1, c, cp1Witness), \"First multiplication check failed\");\n      require(ecmulVerify(p2, s, sp2Witness), \"Second multiplication check failed\");\n      return affineECAdd(cp1Witness, sp2Witness, zInv);\n    }\n\n  // Domain-separation tag for the hash taken in scalarFromCurvePoints.\n  // Corresponds to scalarFromCurveHashPrefix in vrf.go\n  uint256 constant SCALAR_FROM_CURVE_POINTS_HASH_PREFIX = 2;\n\n  // Pseudo-random number from inputs. Matches vrf.go/scalarFromCurvePoints, and\n  // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-vrf-05#section-5.4.3\n  // The draft calls (in step 7, via the definition of string_to_int, in\n  // https://datatracker.ietf.org/doc/html/rfc8017#section-4.2 ) for taking the\n  // first hash without checking that it corresponds to a number less than the\n  // group order, which will lead to a slight bias in the sample.\n  //\n  // TODO(alx): We could save a bit of gas by following the standard here and\n  // using the compressed representation of the points, if we collated the y\n  // parities into a single bytes32.\n  // https://www.pivotaltracker.com/story/show/171120588\n  function scalarFromCurvePoints(\n    uint256[2] memory hash, uint256[2] memory pk, uint256[2] memory gamma,\n    address uWitness, uint256[2] memory v)\n    internal pure returns (uint256 s) {\n      return uint256(\n        keccak256(abi.encodePacked(SCALAR_FROM_CURVE_POINTS_HASH_PREFIX,\n                                   hash, pk, gamma, v, uWitness)));\n    }\n\n  // True if (gamma, c, s) is a correctly constructed randomness proof from pk\n  // and seed. zInv must be the inverse of the third ordinate from\n  // projectiveECAdd applied to cGammaWitness and sHashWitness. Corresponds to\n  // section 5.3 of the IETF draft.\n  //\n  // TODO(alx): Since I'm only using pk in the ecrecover call, I could only pass\n  // the x ordinate, and the parity of the y ordinate in the top bit of uWitness\n  // (which I could make a uint256 without using any extra space.) Would save\n  // about 2000 gas. https://www.pivotaltracker.com/story/show/170828567\n  function verifyVRFProof(\n    uint256[2] memory pk, uint256[2] memory gamma, uint256 c, uint256 s,\n    uint256 seed, address uWitness, uint256[2] memory cGammaWitness,\n    uint256[2] memory sHashWitness, uint256 zInv)\n    internal view {\n      require(isOnCurve(pk), \"public key is not on curve\");\n      require(isOnCurve(gamma), \"gamma is not on curve\");\n      require(isOnCurve(cGammaWitness), \"cGammaWitness is not on curve\");\n      require(isOnCurve(sHashWitness), \"sHashWitness is not on curve\");\n      // Step 5. of IETF draft section 5.3 (pk corresponds to 5.3's Y, and here\n      // we use the address of u instead of u itself. Also, here we add the\n      // terms instead of taking the difference, and in the proof consruction in\n      // vrf.GenerateProof, we correspondingly take the difference instead of\n      // taking the sum as they do in step 7 of section 5.1.)\n      require(\n        verifyLinearCombinationWithGenerator(c, pk, s, uWitness),\n        \"addr(c*pk+s*g)_uWitness\"\n      );\n      // Step 4. of IETF draft section 5.3 (pk corresponds to Y, seed to alpha_string)\n      uint256[2] memory hash = hashToCurve(pk, seed);\n      // Step 6. of IETF draft section 5.3, but see note for step 5 about +/- terms\n      uint256[2] memory v = linearCombination(\n        c, gamma, cGammaWitness, s, hash, sHashWitness, zInv);\n      // Steps 7. and 8. of IETF draft section 5.3\n      uint256 derivedC = scalarFromCurvePoints(hash, pk, gamma, uWitness, v);\n      require(c == derivedC, \"invalid proof\");\n    }\n\n  // Domain-separation tag for the hash used as the final VRF output.\n  // Corresponds to vrfRandomOutputHashPrefix in vrf.go\n  uint256 constant VRF_RANDOM_OUTPUT_HASH_PREFIX = 3;\n\n  // Length of proof marshaled to bytes array. Shows layout of proof\n  uint private constant PROOF_LENGTH = 64 + // PublicKey (uncompressed format.)\n    64 + // Gamma\n    32 + // C\n    32 + // S\n    32 + // Seed\n    0 + // Dummy entry: The following elements are included for gas efficiency:\n    32 + // uWitness (gets padded to 256 bits, even though it's only 160)\n    64 + // cGammaWitness\n    64 + // sHashWitness\n    32; // zInv  (Leave Output out, because that can be efficiently calculated)\n\n  /* ***************************************************************************\n   * @notice Returns proof's output, if proof is valid. Otherwise reverts\n\n   * @param proof A binary-encoded proof, as output by vrf.Proof.MarshalForSolidityVerifier\n   *\n   * Throws if proof is invalid, otherwise:\n   * @return output i.e., the random output implied by the proof\n   * ***************************************************************************\n   * @dev See the calculation of PROOF_LENGTH for the binary layout of proof.\n   */\n  function randomValueFromVRFProof(bytes memory proof)\n    internal view returns (uint256 output) {\n      require(proof.length == PROOF_LENGTH, \"wrong proof length\");\n\n      uint256[2] memory pk; // parse proof contents into these variables\n      uint256[2] memory gamma;\n      // c, s and seed combined (prevents \"stack too deep\" compilation error)\n      uint256[3] memory cSSeed;\n      address uWitness;\n      uint256[2] memory cGammaWitness;\n      uint256[2] memory sHashWitness;\n      uint256 zInv;\n      (pk, gamma, cSSeed, uWitness, cGammaWitness, sHashWitness, zInv) = abi.decode(\n        proof, (uint256[2], uint256[2], uint256[3], address, uint256[2],\n                uint256[2], uint256));\n      verifyVRFProof(\n        pk,\n        gamma,\n        cSSeed[0], // c\n        cSSeed[1], // s\n        cSSeed[2], // seed\n        uWitness,\n        cGammaWitness,\n        sHashWitness,\n        zInv\n      );\n      output = uint256(keccak256(abi.encode(VRF_RANDOM_OUTPUT_HASH_PREFIX, gamma)));\n    }\n}\n",
		"VRFRequestIDBase.sol": "pragma solidity 0.6.2;\n\ncontract VRFRequestIDBase {\n\n  /**\n   * @notice returns the seed which is actually input to the VRF\n   *\n   * @dev To prevent repetition of VRF output due to repetition against the\n   * @dev user-supplied seed, that seed is combined in a hash with the a\n   * @dev user-specific nonce, and the address of the consuming contract.\n   *\n   * @dev Of course, crucial security guranatees would be broken by repetition\n   * @dev of the user-supplied seed, as all the other inputs can be anticipated\n   * @dev and the user-specified seed is public once the initial request is\n   * @dev made, so if the oracle has reason to belive that a user-specified seed\n   * @dev will be repeated, it may be able to anticipate its future outputs. So\n   * @dev it may make sense, for certain applications, for the VRF framework to\n   * @dev simply refuse to operate, if given a seed it's seen before.\n   *\n   * @param _userSeed VRF seed input provided by user\n   * @param _requester Address of the requesting contract\n   * @param _nonce User-specific nonce at the time of the request\n   */\n  function makeVRFInputSeed(bytes32 _keyHash, uint256 _userSeed,\n    address _requester, uint256 _nonce)\n    internal pure returns (uint256)\n  {\n    return  uint256(keccak256(abi.encode(_keyHash, _userSeed, _requester, _nonce)));\n  }\n\n  /**\n   * @notice Returns the id for this request\n   * @param _keyHash The serviceAgreement ID to be used for this request\n   * @param _vRFInputSeed The seed to be passed directly to the VRF\n   * @return The id for this request\n   *\n   * @dev Note that _vRFInputSeed is not the seed passed by the consuming\n   * @dev contract, but the one generated by makeVRFInputSeed\n   */\n  function makeRequestId(\n    bytes32 _keyHash, uint256 _vRFInputSeed) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_keyHash, _vRFInputSeed));\n  }\n}\n",
		"VRFConsumerBase.sol": "pragma solidity 0.6.2;\n\nimport \"./vendor/SafeMath.sol\";\n\nimport \"./interfaces/LinkTokenInterface.sol\";\n\nimport \"./VRFRequestIDBase.sol\";\n\n/** ****************************************************************************\n * @notice Interface for contracts using VRF randomness\n * *****************************************************************************\n * @dev PURPOSE\n *\n * @dev Reggie the Random Oracle (not his real job) wants to provide randomness\n * @dev to Vera the verifier in such a way that Vera can be sure he's not\n * @dev making his output up to suit himself. Reggie provides Vera a public key\n * @dev to which he knows the secret key. Each time Vera provides a seed to\n * @dev Reggie, he gives back a value which is computed completely\n * @dev deterministically from the seed and the secret key.\n *\n * @dev Reggie provides a proof by which Vera can verify that the output was\n * @dev correctly computed once Reggie tells it to her, but without that proof,\n * @dev the output is indistinguishable to her from a uniform random sample\n * @dev from the output space.\n *\n * @dev The purpose of this contract is to make it easy for unrelated contracts\n * @dev to talk to Vera the verifier about the work Reggie is doing, to provide\n * @dev simple access to a verifiable source of randomness.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFConsumerInterface, and can\n * @dev initialize VRFConsumerInterface's attributes in their constructor as\n * @dev shown:\n *\n * @dev   contract VRFConsumer {\n * @dev     constuctor(<other arguments>, address _vrfCoordinator, address _link)\n * @dev       VRFConsumerBase(_vrfCoordinator, _link) public {\n * @dev         <initialization with other arguments goes here>\n * @dev       }\n * @dev   }\n *\n * @dev The oracle will have given you an ID for the VRF keypair they have\n * @dev committed to (let's call it keyHash), and have told you the minimum LINK\n * @dev price for VRF service. Make sure your contract has sufficient LINK, and\n * @dev call requestRandomness(keyHash, fee, seed), where seed is the input you\n * @dev want to generate randomness from.\n *\n * @dev Once the VRFCoordinator has received and validated the oracle's response\n * @dev to your request, it will call your contract's fulfillRandomness method.\n *\n * @dev The randomness argument to fulfillRandomness is the actual random value\n * @dev generated from your seed.\n *\n * @dev The requestId argument is generated from the keyHash and the seed by\n * @dev makeRequestId(keyHash, seed). If your contract could have concurrent\n * @dev requests open, you can use the requestId to track which seed is\n * @dev associated with which randomness. See VRFRequestIDBase.sol for more\n * @dev details.\n *\n * @dev Colliding `requestId`s are cryptographically impossible as long as seeds\n * @dev differ. (Which is critical to making unpredictable randomness! See the\n * @dev next section.)\n *\n * *****************************************************************************\n * @dev SECURITY CONSIDERATIONS\n *\n * @dev To increase trust in your contract, the source of your seeds should be\n * @dev hard for anyone to influence or predict. Any party who can influence\n * @dev them could in principle collude with the oracle (who can instantly\n * @dev compute the VRF output for any given seed) to bias the outcomes from\n * @dev your contract in their favor. For instance, the block hash is a natural\n * @dev choice of seed for many applications, but miners in control of a\n * @dev substantial fraction of hashing power and with access to VRF outputs\n * @dev could check the result of prospective block hashes as they are mined,\n * @dev and decide not to publish a block if they don't like the outcome it will\n * @dev lead to.\n *\n * @dev On the other hand, using block hashes as the seed makes it particularly\n * @dev easy to estimate the economic cost to a miner for this kind of cheating\n * @dev (namely, the block reward and transaction fees they forgo by refraining\n * @dev from publishing a block.)\n */\nabstract contract VRFConsumerBase is VRFRequestIDBase {\n\n  using SafeMath for uint256;\n\n  /**\n   * @notice fulfillRandomness handles the VRF response. Your contract must\n   * @notice implement it.\n   *\n   * @dev The VRFCoordinator expects a calling contract to have a method with\n   * @dev this signature, and will call it once it has verified the proof\n   * @dev associated with the randomness.\n   *\n   * @param requestId The Id initially returned by requestRandomness\n   * @param randomness the VRF output\n   */\n  function fulfillRandomness(bytes32 requestId, uint256 randomness)\n    external virtual;\n\n  /**\n   * @notice requestRandomness initiates a request for VRF output given _seed\n   *\n   * @dev The source of the seed data must be something which the oracle\n   * @dev cannot anticipate. See \"SECURITY CONSIDERATIONS\" above.\n   *\n   * @dev The fulfillRandomness method receives the output, once it's provided\n   * @dev by the Oracle, and verified by the vrfCoordinator.\n   *\n   * @dev The _keyHash must already be registered with the VRFCoordinator, and\n   * @dev the _fee must exceed the fee specified during registration of the\n   * @dev _keyHash.\n   *\n   * @param _keyHash ID of public key against which randomness is generated\n   * @param _fee The amount of LINK to send with the request\n   * @param _seed Random seed from which output randomness is determined\n   *\n   * @return requestId which will be returned with the response to this request\n   *\n   * @dev The returned requestId can be used to distinguish responses to *\n   * @dev concurrent requests. It is passed as the first argument to\n   * @dev fulfillRandomness.\n   */\n  function requestRandomness(bytes32 _keyHash, uint256 _fee, uint256 _seed)\n    public returns (bytes32 requestId)\n  {\n    LINK.transferAndCall(vrfCoordinator, _fee, abi.encode(_keyHash, _seed));\n    // This is the seed actually passed to the VRF in VRFCoordinator\n    uint256 vRFSeed  = makeVRFInputSeed(_keyHash, _seed, address(this), nonces[_keyHash]);\n    // nonces[_keyHash] must stay in sync with\n    // VRFCoordinator.nonces[_keyHash][this], which was incremented by the above\n    // successful LINK.transferAndCall (in VRFCoordinator.randomnessRequest)\n    nonces[_keyHash] = nonces[_keyHash].add(1); \n    return makeRequestId(_keyHash, vRFSeed);\n  }\n\n  LinkTokenInterface internal LINK;\n  address internal vrfCoordinator;\n\n  // Nonces for each VRF key from which randomness has been requested.\n  //\n  // Must stay in sync with VRFCoordinator[_keyHash][this]\n  mapping(bytes32 /* keyHash */ => uint256 /* nonce */) public nonces;\n  constructor(address _vrfCoordinator, address _link) public {\n    vrfCoordinator = _vrfCoordinator;\n    LINK = LinkTokenInterface(_link);\n  }\n}\n"
	},
	"sourceTreeHashHex": "0xc8a6b15c9cf94746da2dbf3b28a9ac15903ac97ca3d30c35581dc012869f3a83",
	"compiler": {
		"name": "solc",
		"version": "soljson-v0.6.2+commit.bacdbe57.js",
		"settings": {
			"optimizer": {
				"enabled": false
			},
			"outputSelection": {
				"*": {
					"*": [
						"abi",
						"devdoc",
						"userdoc",
						"evm.bytecode.object",
						"evm.bytecode.sourceMap",
						"evm.deployedBytecode.object",
						"evm.deployedBytecode.sourceMap",
						"evm.methodIdentifiers",
						"metadata"
					]
				}
			},
			"remappings": []
		}
	},
	"chains": {}
}